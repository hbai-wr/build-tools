#!/bin/bash

#
# Copyright (c) 2021 Wind River Systems, Inc.
#
# SPDX-License-Identifier: Apache-2.0
#

#
set -e

echo "Run build-extl-pkg"
exit 0

BUILD_PKGS_SERIAL_DIR="$(dirname "$(readlink -f "${BASH_SOURCE[0]}" )" )"

#source "${BUILD_PKGS_SERIAL_DIR}/git-utils.sh"

usage () {
    echo ""
    echo "Usage: "
    echo "   Create source and Binary rpms:"
    echo "   build-sdeb-pkgs PACKAGE_NAME PACKAGE_META_DIR"
    echo ""
}

function client_ready() {
    local ret=`osc ls | grep starlingx\:distro`
    if [ "x$ret" == "x" ]; then
        echo "build client is not ready"
	exit 1
    fi
}

function get_obs_prj() {
    local pkg_name=$1
    local pkg_path=$2
    local obs_prj=""

    local obs_prj=`osc search $pkg_name`
    local ret=`echo $obs_prj | grep '# Project' | grep '# Package'`
    if [ "x$ret" != "x" ]; then
        obs_prj=`echo ${obs_prj##*$'\n'}`
	obs_prj=`echo $obs_prj | awk -F" " '{print $1}'`
    fi
    echo $obs_prj
}

function branch_existed_pkg() {
   local pkg_name=$1
   local obs_prj=$2

   local branch_info=`osc branch $obs_prj $pkg_name`
   local ret=`echo $branch_info | grep "A working copy of the branched package"`
   if [ "x$ret" == "x" ]; then
       echo "fail to branch package fail"
       exit 1
   fi
   local branch_name=`echo $branch_info | grep "^osc co" | awk -F" " '{print $3}'`
   if [ "x$branch_name" != "x" ]; then
       echo "package branch to $branch_name"
       osc co -c $branch_name
   fi
}

function branch_new_pkg() {
   local pkg_name=$1
   local obs_prj=$2

   local branch_info=`osc branch $obs_prj $pkg_name`
   local ret=`echo $branch_info | grep "A working copy of the branched package"`
   if [ "x$ret" == "x" ]; then
       echo "fail to branch package fail"
       exit 1
   fi
   local branch_name=`echo $branch_info | grep "^osc co" | awk -F" " '{print $3}'`
   if [ "x$branch_name" != "x" ]; then
       echo "package branch to $branch_name"
       osc co -c $branch_name
   fi
}

while true ; do
    case "$1" in
        --append-log)     APPEND_LOG_FLAG=1 ; shift ;;
        --build-avoidance) BUILD_AVOIDANCE_FLAG=1 ; shift ;;
        --no-build-avoidance) BUILD_AVOIDANCE_FLAG=0 ; shift ;;
        --build-avoidance-dir)  BUILD_AVOIDANCE_OVERRIDE_DIR=$2; shift 2 ;;
        --build-avoidance-host)  BUILD_AVOIDANCE_OVERRIDE_HOST=$2; shift 2 ;;
        --build-avoidance-user)  BUILD_AVOIDANCE_OVERRIDE_USR=$2; shift 2 ;;
        --build-avoidance-day) BUILD_AVOIDANCE_DAY=$2; shift 2 ;;
        --no-descendants) EXTRA_ARGS_COMMON+=" --no-descendants" ; shift ;;
        --formal)         EXTRA_ARGS_COMMON+=" --formal" ; shift ;;
        --careful)        EXTRA_ARGS_RPM+=" --careful" ; shift ;;
        --layer)          EXTRA_ARGS_COMMON+=" --layer=$2"; shift 2 ;;
        --no-required)    EXTRA_ARGS_RPM+=" --no-required" ; shift ;;
        --no-build-info)  EXTRA_ARGS_COMMON+=" --no-build-info" ; shift ;;
        --no-autoclean)   EXTRA_ARGS_RPM+=" --no-autoclean" ; shift ;;
        --no-meta-patch)  EXTRA_ARGS_SRPM+=" --no-meta-patch" ; shift ;;
        -h|--help)        HELP=1 ; shift ;;
        --clean)          CLEAN_FLAG=1 ; shift ;;
        --dep-test)       DEP_TEST_FLAG=1; EXTRA_ARGS_RPM+=" --dep-test"; shift ;;
        --edit)           EDIT_FLAG=1 ; EXTRA_ARGS_SRPM+=" --edit"; shift ;;
        --rt)             STD_BUILD=0 ; shift ;;
        --std)            RT_BUILD=0 ; shift ;;
        --installer)      INSTALLER_BUILD=1 ; STD_BUILD=0 ; RT_BUILD=0 ; shift ;;
        --containers)     INSTALLER_BUILD=0 ; STD_BUILD=0 ; RT_BUILD=0 ; CONTAINERS_BUILD=1;shift ;;
        --serial)         shift ;;
        --)               shift ; break ;;
        *)                usage; exit 1 ;;
    esac
done

if [ $HELP -eq 1 ]; then
    usage
    exit 0
fi

# Don't source until after BUILD_AVOIDANCE_OVERRIDE_* variables are set.
source "${BUILD_PKGS_SERIAL_DIR}/build-avoidance-utils.sh"

function my_exit() {
    build-rpms-parallel --std --tmpfs-clean
    build-rpms-parallel --rt --tmpfs-clean
}

function my_sigint() {
    echo "build-pkgs-parallel sigint"
    pkill -SIGABRT -P $BASHPID &> /dev/null
    echo "build-pkgs-parallel waiting"
    wait
    echo "build-pkgs-parallel wait complete"

}

function my_sighup() {
    echo "build-pkgs-parallel sighup"
    pkill -SIGABRT -P $BASHPID &> /dev/null
    echo "build-pkgs-parallel waiting"
    wait
    echo "build-pkgs-parallel wait complete"
}

function my_sigabrt() {
    echo "build-pkgs-parallel sigabrt"
    pkill -SIGABRT -P $BASHPID &> /dev/null
    echo "build-pkgs-parallel waiting"
    wait
    echo "build-pkgs-parallel wait complete"
}

function my_sigterm() {
    echo "build-pkgs-parallel sigterm"
    pkill -SIGABRT -P $BASHPID &> /dev/null
    echo "build-pkgs-parallel waiting"
    wait
    echo "build-pkgs-parallel wait complete"
}

trap my_exit EXIT
trap my_sigint INT
trap my_sighup HUP
trap my_sigabrt ABRT
trap my_sigterm TERM
